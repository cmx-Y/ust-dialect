[English](#en) | [中文](#cn)

<span id="en">MLIR Add A New Pass Tutorial</span>
===========================
As described in the previous tutorials, a Pass, in simple terms, is a transformation applied to the graph represented by an MLIR program. For detailed information about Passes, please refer to the official documentation at: https://mlir.llvm.org/docs/PassManagement/. In MLIR, Passes are managed by the PassManager. If you want to apply a pass to a specific MLIR program, you should add that pass to the PassManager.Without unnecessary verbosity. Let's dive into an example. Suppose you want to add a pass, you should follow these steps:

**1.Declare the Pass in include/ust/Transforms/Passes.td**

For example:

```c++
def LoopBoundConstant : Pass<"loop-bound-const", "ModuleOp"> {
  let summary = "Transform loop bound to constant pass";
  let constructor = "mlir::ust::createLoopBoundConstantPass()";
}
```
**2.Declare the Pass Constructor and Pass Operation Function in include/ust/Transforms/Passes.h**

For example:

```c++
std::unique_ptr<OperationPass<ModuleOp>> createLoopBoundConstantPass();
This function corresponds to the constructor in Passes.td.
```
For example:

```c++
bool applyUSTLoopBoundConstant(ModuleOp &module);
```
This function involves the specific implementation of the LoopBoundConstant Pass. Its input is a ModuleOp, which can be understood simply as an MLIR program.

**3.Create the Source File under lib/Transforms/**

For example, create lib/Transforms/LoopBoundConstant.cpp.

Within this file, define the following structure:

```c++
struct USTLoopBoundConstantTransformation
    : public LoopBoundConstantBase<USTLoopBoundConstantTransformation> {
  void runOnOperation() override {
    auto mod = getOperation();
    if (!applyUSTLoopBoundConstant(mod)) {
      signalPassFailure();
    }
  }
};
```
This structure inherits from LoopBoundConstantBase, which is auto-generated by the ODS framework based on Passes.td. The structure contains a crucial function runOnOperation(), indicating that passes operate on operations at a certain level, such as ModuleOp in this case.

This file also includes the specific implementation of the pass constructor:

```c++
std::unique_ptr<OperationPass<ModuleOp>> createLoopBoundConstantPass() {
  return std::make_unique<USTLoopBoundConstantTransformation>();
}
```
And the specific operation of the pass:

```c++
/// Pass entry point
bool applyUSTLoopBoundConstant(ModuleOp &module) {
  for (func::FuncOp func : module.getOps<func::FuncOp>()) {
    if (func.getBlocks().empty()) {
      continue;
    }
  }
  return true;
}
```
Key pass-related code should be written within this function.


<span id="cn">MLIR添加Pass指北</span>
===========================
如前文教程所述，Pass 简单来说就是对 mlir 程序所表示的图进行变换。关于 Pass 的详细信息请参考官方文档：https://mlir.llvm.org/docs/PassManagement/ 。在 MLIR 中，Pass 由 PassManager 进行管理，如果你想对某个 mlir 程序施加某个 pass，就应该将该 pass 加入 PassManager。废话少说，直接举例，假设你想添加某个 pass，应该依次完成如下步骤。


**1.在 include/ust/Transforms/Passes.td 中声明 Pass**
例如
```c++
def LoopBoundConstant : Pass<"loop-bound-const", "ModuleOp"> {
  let summary = "Transform loop bound to constant pass";
  let constructor = "mlir::ust::createLoopBoundConstantPass()";
}
```

**2.在 include/ust/Transforms/Passes.h 中声明 Pass constructor 以及 Pass 操作函数**
例如
```c++
std::unique_ptr<OperationPass<ModuleOp>> createLoopBoundConstantPass();
```
该函数对应 `Passes.td` 中的 constructor。

例如
```c++
bool applyUSTLoopBoundConstant(ModuleOp &module);
```
该函数涉及到 LoopBoundConstant Pass 的具体实现，它的输入是一个 ModuleOp，可以简单理解为一个 mlir 程序。

**3.在lib/Transforms/文件夹下创建源文件**
例如创建 `lib/Transforms/LoopBoundConstant.cpp`,

该文件中的函数
```c++
struct USTLoopBoundConstantTransformation
    : public LoopBoundConstantBase<USTLoopBoundConstantTransformation> {
  void runOnOperation() override {
    auto mod = getOperation();
    if (!applyUSTLoopBoundConstant(mod)) {
      signalPassFailure();
    }
  }
};
```
继承自 `LoopBoundConstantBase`，这个结构体实际上是 ODS 框架根据 Passes.td 自动生成的。该结构体中有一个重要函数 `runOnOperation()`，说明 pass 都是在某个层次上的 operation 进行的，例如这里的 moduleOp。

该文件中还包含 pass constructor 的具体实现：
```c++
std::unique_ptr<OperationPass<ModuleOp>> createLoopBoundConstantPass() {
  return std::make_unique<USTLoopBoundConstantTransformation>();
}
```

该文件中还包含 pass 的具体操作：
```c++
/// Pass entry point
bool applyUSTLoopBoundConstant(ModuleOp &module) {
  for (func::FuncOp func : module.getOps<func::FuncOp>()) {
    if (func.getBlocks().empty()) {
      continue;
    }
  }
  return true;
}
```
Pass 的关键代码都需要写在这个函数中。